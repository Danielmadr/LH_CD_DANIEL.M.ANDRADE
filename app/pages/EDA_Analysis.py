
import streamlit as st
import pandas as pd
import sqlite3
import plotly.express as px


def carregar_dados_db(db_path):
    conn = sqlite3.connect(db_path)
    df = pd.read_sql_query("SELECT * FROM movies", conn)
    conn.close()
    return df

def plot_correlation_matrix(df: pd.DataFrame):
    # Selecionar apenas colunas num√©ricas relevantes
    colunas_relevantes = [
        'Released_Year', 'Runtime', 'IMDB_Rating', 'Meta_score', 'No_of_Votes', 'Gross'
    ]
    df_corr = df[colunas_relevantes].copy()
    corr = df_corr.corr()
    # Melhorar nomes das colunas para o gr√°fico
    corr.index.name = 'Vari√°vel'
    corr.columns.name = 'Vari√°vel'
    fig = px.imshow(
        corr,
        text_auto='.2f',
        color_continuous_scale='RdBu_r',
        title="Matriz de Correla√ß√£o",
        labels=dict(color="Correla√ß√£o"),
        x=corr.columns,
        y=corr.index
    )
    fig.update_layout(
        title_x=0.5,
        width=800,
        height=600
    )
    st.plotly_chart(fig, use_container_width=True)

    # Extrair correla√ß√µes mais altas (excluindo diagonal)
    st.subheader("Principais Correla√ß√µes")
    corr_pairs = []
    for i in range(len(corr.columns)):
        for j in range(i+1, len(corr.columns)):
            var1 = corr.columns[i]
            var2 = corr.columns[j]
            corr_val = corr.iloc[i, j]
            if not pd.isna(corr_val):
                corr_pairs.append({
                    'Vari√°vel 1': var1,
                    'Vari√°vel 2': var2,
                    'For√ßa': abs(corr_val)
                })
    if corr_pairs:
        corr_df = pd.DataFrame(corr_pairs).sort_values('For√ßa', ascending=False).reset_index(drop=True)
        st.dataframe(corr_df.head(10))
    return fig

def plot_top_recommendations(df: pd.DataFrame):
    # Crit√©rios: Alta nota IMDB (>=8.0) + Muitos votos (acima do percentil 70) + G√™neros populares
    st.markdown(
        """
        **Crit√©rios para recomenda√ß√£o:**
        - Nota IMDB ‚â• 8.0
        - N√∫mero de votos acima do percentil 70
        - G√™neros mais frequentes entre os melhores
        
        """
    )
    high_rated = df[df['IMDB_Rating'] >= 8.0]
    popular = high_rated[high_rated['No_of_Votes'] >= high_rated['No_of_Votes'].quantile(0.7)]

    # Gr√°fico 1: Distribui√ß√£o de Rating vs Votos (apenas filmes populares)
    fig1 = px.scatter(
        popular,
        x='No_of_Votes',
        y='IMDB_Rating',
        color='Genre',
        size='IMDB_Rating',
        hover_data=['Series_Title', 'Released_Year'],
        title='Rating vs Popularidade (Filmes Populares)',
        subtitle= "Nota: Um filme √© considerado popular nesta an√°lise se possui nota IMDB igual ou superior a 8.0 e est√° entre os 30% com maior n√∫mero de votos.",
        labels={'No_of_Votes': 'N√∫mero de Votos', 'IMDB_Rating': 'Rating IMDB'}
    )
    fig1.update_xaxes(type='log')
    st.plotly_chart(fig1, use_container_width=True)

    # Gr√°fico 2: Distribui√ß√£o por g√™nero dos filmes bem avaliados
    genre_counts = popular['Genre'].value_counts().head(10)
    fig2 = px.bar(
        x=genre_counts.values,
        y=genre_counts.index,
        orientation='h',
        title='G√™neros Mais Populares (Rating ‚â• 8.0)',
        labels={'x': 'N√∫mero de Filmes', 'y': 'G√™nero'}
    )
    fig2.update_layout(yaxis={'categoryorder': 'total ascending'})
    st.plotly_chart(fig2, use_container_width=True)

    # Top 10 filmes recomendados (desempate por votos)
    top_recommendations = popular.sort_values(
        ['IMDB_Rating', 'No_of_Votes'], ascending=[False, False]
    ).head(10)[['Series_Title', 'IMDB_Rating', 'No_of_Votes', 'Genre', 'Released_Year']]

    st.subheader("üèÜ Top 10 Filmes Recomendados")
    st.dataframe(top_recommendations)

    return top_recommendations

def analise_fatores_faturamento(df: pd.DataFrame):
    """
    An√°lise completa dos fatores que influenciam o faturamento dos filmes
    """
    import plotly.graph_objects as go
    from plotly.subplots import make_subplots
    
    # Filtrar apenas filmes com dados de faturamento
    df_revenue = df.dropna(subset=['Gross']).copy()
    
    if len(df_revenue) == 0:
        st.warning("N√£o h√° dados suficientes de faturamento para an√°lise.")
        return
    
    st.markdown(f"**Dados dispon√≠veis:** {len(df_revenue):,} filmes com informa√ß√µes de faturamento")
    
    # Criar categorias de faturamento
    df_revenue['Faturamento_Categoria'] = pd.cut(
        df_revenue['Gross'], 
        bins=[0, 50_000_000, 200_000_000, float('inf')],
        labels=['Baixo (<$50M)', 'M√©dio ($50M-$200M)', 'Alto (>$200M)']
    )
    
    # 1. CORRELA√á√ÉO COM FATURAMENTO
    st.subheader("üîç Correla√ß√£o das Vari√°veis com Faturamento")
    
    # Calcular correla√ß√µes
    colunas_numericas = ['Released_Year', 'Runtime', 'IMDB_Rating', 'Meta_score', 'No_of_Votes']
    correlacoes = []
    
    for col in colunas_numericas:
        if col in df_revenue.columns:
            corr = df_revenue[col].corr(df_revenue['Gross'])
            if not pd.isna(corr):
                correlacoes.append({'Vari√°vel': col, 'Correla√ß√£o': corr, 'Abs_Correla√ß√£o': abs(corr)})
    
    if correlacoes:
        corr_df = pd.DataFrame(correlacoes).sort_values('Abs_Correla√ß√£o', ascending=False)
        
        # Gr√°fico de barras das correla√ß√µes
        fig_corr = px.bar(
            corr_df, 
            x='Correla√ß√£o', 
            y='Vari√°vel',
            orientation='h',
            title='Correla√ß√£o das Vari√°veis com Faturamento',
            color='Correla√ß√£o',
            color_continuous_scale='RdBu_r',
            text='Correla√ß√£o'
        )
        fig_corr.update_traces(texttemplate='%{text:.3f}', textposition='outside')
        fig_corr.update_layout(yaxis={'categoryorder': 'total ascending'})
        st.plotly_chart(fig_corr, use_container_width=True)
        
        # Tabela de correla√ß√µes
        st.dataframe(corr_df[['Vari√°vel', 'Correla√ß√£o']].round(3))
    
    # 2. AN√ÅLISE POR RATING IMDB
    st.subheader("‚≠ê Faturamento por Faixa de Rating IMDB")
    
    # Criar faixas de rating
    df_revenue['Rating_Faixa'] = pd.cut(
        df_revenue['IMDB_Rating'], 
        bins=[0, 6.5, 7.5, 8.5, 10],
        labels=['Baixo (‚â§6.5)', 'M√©dio (6.5-7.5)', 'Alto (7.5-8.5)', 'Excelente (>8.5)']
    )
    
    rating_stats = df_revenue.groupby('Rating_Faixa', observed=True)['Gross'].agg([
        'count', 'mean', 'median', 'std'
    ]).round(2)
    rating_stats.columns = ['Quantidade', 'M√©dia', 'Mediana', 'Desvio Padr√£o']
    
    # Box plot por rating
    fig_box = px.box(
        df_revenue, 
        x='Rating_Faixa', 
        y='Gross',
        title='Distribui√ß√£o de Faturamento por Faixa de Rating IMDB'
    )
    fig_box.update_yaxes(title='Faturamento (US$)')
    st.plotly_chart(fig_box, use_container_width=True)
    
    st.dataframe(rating_stats)
    
    # 3. AN√ÅLISE POR G√äNERO
    st.subheader("üé¨ Faturamento por G√™nero")
    
    # Processar g√™neros (pegar apenas o primeiro g√™nero)
    df_revenue['Genero_Principal'] = df_revenue['Genre'].str.split(',').str[0]
    genero_stats = df_revenue.groupby('Genero_Principal')['Gross'].agg([
        'count', 'mean', 'median'
    ]).sort_values('mean', ascending=False).head(10)
    genero_stats.columns = ['Quantidade', 'Faturamento_M√©dio', 'Faturamento_Mediano']
    
    # Filtrar g√™neros com pelo menos 5 filmes
    genero_stats_filtered = genero_stats[genero_stats['Quantidade'] >= 5]
    
    fig_genero = px.bar(
        x=genero_stats_filtered.index,
        y=genero_stats_filtered['Faturamento_M√©dio'],
        title='Faturamento M√©dio por G√™nero (min. 5 filmes)',
        labels={'x': 'G√™nero', 'y': 'Faturamento M√©dio (US$)'}
    )
    fig_genero.update_xaxes(tickangle=45)
    st.plotly_chart(fig_genero, use_container_width=True)
    
    st.dataframe(genero_stats_filtered)
    
    # 4. AN√ÅLISE POR ANO DE LAN√áAMENTO
    st.subheader("üìÖ Evolu√ß√£o do Faturamento por D√©cada")
    
    # Criar d√©cadas
    df_revenue['Decada'] = (df_revenue['Released_Year'] // 10) * 10
    decada_stats = df_revenue.groupby('Decada')['Gross'].agg([
        'count', 'mean', 'median'
    ]).dropna()
    
    fig_decada = px.line(
        x=decada_stats.index,
        y=decada_stats['mean'],
        title='Evolu√ß√£o do Faturamento M√©dio por D√©cada',
        labels={'x': 'D√©cada', 'y': 'Faturamento M√©dio (US$)'},
        markers=True
    )
    st.plotly_chart(fig_decada, use_container_width=True)
    return df_revenue

def analise_overview_insights(df: pd.DataFrame):
    """
    An√°lise completa da coluna Overview para extrair insights e inferir g√™neros
    """
    import re
    from collections import Counter
    import plotly.graph_objects as go
    from plotly.subplots import make_subplots
    import numpy as np
    
    # Filtrar dados v√°lidos de Overview
    df_overview = df.dropna(subset=['Overview']).copy()
    df_overview = df_overview[df_overview['Overview'].str.len() > 10]  # Filtrar descri√ß√µes muito curtas
    
    if len(df_overview) == 0:
        st.warning("N√£o h√° dados suficientes de Overview para an√°lise.")
        return
    
    st.markdown(f"**Dados dispon√≠veis:** {len(df_overview):,} filmes com descri√ß√µes v√°lidas")
    
    # ========== AN√ÅLISES B√ÅSICAS DE TEXTO ==========
    st.subheader("üìù Caracter√≠sticas das Descri√ß√µes")
    
    # Estat√≠sticas b√°sicas
    df_overview['overview_length'] = df_overview['Overview'].str.len()
    df_overview['overview_words'] = df_overview['Overview'].str.split().str.len()
    
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        st.metric(
            "Comprimento m√©dio", 
            f"{df_overview['overview_length'].mean():.0f} chars"
        )
    
    with col2:
        st.metric(
            "Palavras m√©dias", 
            f"{df_overview['overview_words'].mean():.0f} palavras"
        )
    
    with col3:
        st.metric(
            "Descri√ß√£o mais longa", 
            f"{df_overview['overview_length'].max()} chars"
        )
    
    with col4:
        st.metric(
            "Descri√ß√£o mais curta", 
            f"{df_overview['overview_length'].min()} chars"
        )
    
    # Distribui√ß√£o do comprimento das descri√ß√µes
    fig_length = px.histogram(
        df_overview,
        x='overview_length',
        nbins=50,
        title='Distribui√ß√£o do Comprimento das Descri√ß√µes',
        labels={'overview_length': 'Comprimento (caracteres)', 'count': 'Frequ√™ncia'}
    )
    st.plotly_chart(fig_length, use_container_width=True)
    
    # ========== AN√ÅLISE DE PALAVRAS-CHAVE ==========
    st.subheader("üîç Palavras-Chave Mais Frequentes")
    
    # Fun√ß√£o para limpar e extrair palavras
    def extract_keywords(text):
        # Converter para min√∫sculo e remover pontua√ß√£o
        text = re.sub(r'[^\w\s]', ' ', text.lower())
        # Remover palavras muito comuns (stop words b√°sicas)
        stop_words = {'the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by', 'is', 'are', 'was', 'were', 'be', 'been', 'have', 'has', 'had', 'do', 'does', 'did', 'will', 'would', 'could', 'should', 'may', 'might', 'must', 'can', 'his', 'her', 'its', 'their', 'he', 'she', 'it', 'they', 'him', 'them', 'this', 'that', 'these', 'those', 'when', 'where', 'why', 'how', 'what', 'who', 'which', 'whom', 'whose', 'if', 'because', 'while', 'during', 'before', 'after', 'above', 'below', 'up', 'down', 'out', 'off', 'over', 'under', 'again', 'further', 'then', 'once'}
        
        words = text.split()
        # Filtrar palavras com mais de 2 caracteres que n√£o s√£o stop words
        keywords = [word for word in words if len(word) > 2 and word not in stop_words]
        return keywords
    
    # Extrair todas as palavras-chave
    all_keywords = []
    for overview in df_overview['Overview'].dropna():
        all_keywords.extend(extract_keywords(str(overview)))
    
    # Contar frequ√™ncias
    keyword_counts = Counter(all_keywords)
    top_keywords = keyword_counts.most_common(20)
    
    if top_keywords:
        keywords_df = pd.DataFrame(top_keywords, columns=['Palavra', 'Frequ√™ncia'])
        
        fig_keywords = px.bar(
            keywords_df,
            x='Frequ√™ncia',
            y='Palavra',
            orientation='h',
            title='Top 20 Palavras-Chave Mais Frequentes',
            labels={'Frequ√™ncia': 'N√∫mero de Ocorr√™ncias', 'Palavra': 'Palavra-Chave'}
        )
        fig_keywords.update_layout(yaxis={'categoryorder': 'total ascending'})
        st.plotly_chart(fig_keywords, use_container_width=True)
        
        st.dataframe(keywords_df.head(15))
    
    # ========== AN√ÅLISE POR G√äNERO ==========
    st.subheader("üé≠ Palavras-Chave por G√™nero")
    
    # Processar g√™neros
    df_overview['Genero_Principal'] = df_overview['Genre'].str.split(',').str[0]
    
    # Analisar palavras-chave por g√™nero (top 5 g√™neros mais comuns)
    top_genres = df_overview['Genero_Principal'].value_counts().head(5).index.tolist()
    
    genre_keywords = {}
    for genre in top_genres:
        genre_overviews = df_overview[df_overview['Genero_Principal'] == genre]['Overview']
        genre_words = []
        for overview in genre_overviews.dropna():
            genre_words.extend(extract_keywords(str(overview)))
        
        # Palavras mais comuns neste g√™nero
        genre_keyword_counts = Counter(genre_words)
        genre_keywords[genre] = genre_keyword_counts.most_common(10)
    
    # Criar tabs para cada g√™nero
    if len(top_genres) > 0:
        genre_tabs = st.tabs([f"üìΩÔ∏è {genre}" for genre in top_genres])
        
        for i, genre in enumerate(top_genres):
            with genre_tabs[i]:
                if genre in genre_keywords and genre_keywords[genre]:
                    genre_df = pd.DataFrame(genre_keywords[genre], columns=['Palavra', 'Frequ√™ncia'])
                    
                    fig_genre = px.bar(
                        genre_df,
                        x='Frequ√™ncia',
                        y='Palavra',
                        orientation='h',
                        title=f'Palavras-Chave Mais Comuns - {genre}',
                        color='Frequ√™ncia',
                        color_continuous_scale='viridis'
                    )
                    fig_genre.update_layout(yaxis={'categoryorder': 'total ascending'})
                    st.plotly_chart(fig_genre, use_container_width=True)
                    
                    st.dataframe(genre_df)
    
    # ========== INFER√äNCIA DE G√äNERO ==========
    st.subheader("ü§ñ Infer√™ncia de G√™nero a partir da Descri√ß√£o")
    
    # Criar um modelo simples baseado em palavras-chave caracter√≠sticas
    def create_genre_keywords():
        """Define palavras-chave caracter√≠sticas para cada g√™nero"""
        genre_patterns = {
            'Action': ['fight', 'battle', 'war', 'combat', 'weapon', 'soldier', 'mission', 'chase', 'explosion', 'hero', 'rescue', 'enemy', 'adventure', 'dangerous'],
            'Drama': ['family', 'relationship', 'emotional', 'life', 'story', 'personal', 'struggle', 'human', 'society', 'realistic', 'character', 'psychological'],
            'Comedy': ['funny', 'humor', 'laugh', 'comic', 'hilarious', 'awkward', 'ridiculous', 'silly', 'entertaining', 'lighthearted', 'amusing'],
            'Horror': ['horror', 'scary', 'fear', 'monster', 'ghost', 'supernatural', 'terror', 'nightmare', 'evil', 'dark', 'haunted', 'possessed'],
            'Romance': ['love', 'romantic', 'relationship', 'couple', 'heart', 'passionate', 'wedding', 'marriage', 'dating', 'romance'],
            'Thriller': ['suspense', 'mystery', 'investigation', 'crime', 'detective', 'murder', 'conspiracy', 'danger', 'tension', 'psychological'],
            'Sci-Fi': ['future', 'space', 'alien', 'technology', 'robot', 'scientific', 'experiment', 'planet', 'time', 'machine', 'virtual'],
            'Fantasy': ['magic', 'magical', 'fantasy', 'wizard', 'dragon', 'kingdom', 'quest', 'mythical', 'supernatural', 'enchanted']
        }
        return genre_patterns
    
    def predict_genre(overview_text, genre_patterns):
        """Prediz g√™nero baseado na presen√ßa de palavras-chave"""
        if pd.isna(overview_text):
            return None, 0
        
        text_lower = overview_text.lower()
        genre_scores = {}
        
        for genre, keywords in genre_patterns.items():
            score = sum(1 for keyword in keywords if keyword in text_lower)
            if score > 0:
                genre_scores[genre] = score
        
        if genre_scores:
            best_genre = max(genre_scores, key=genre_scores.get)
            confidence = genre_scores[best_genre] / len(genre_patterns[best_genre])
            return best_genre, confidence
        else:
            return None, 0
    
    # Aplicar modelo de infer√™ncia
    genre_patterns = create_genre_keywords()
    
    predictions = []
    for idx, row in df_overview.iterrows():
        predicted_genre, confidence = predict_genre(row['Overview'], genre_patterns)
        predictions.append({
            'T√≠tulo': row['Series_Title'],
            'G√™nero_Real': row['Genero_Principal'],
            'G√™nero_Predito': predicted_genre,
            'Confian√ßa': confidence,
            'Overview': row['Overview'][:100] + '...'  # Primeiros 100 chars
        })
    
    pred_df = pd.DataFrame(predictions)
    
    # Calcular m√©tricas de acur√°cia
    valid_predictions = pred_df.dropna(subset=['G√™nero_Predito'])
    
    if len(valid_predictions) > 0:
        # Acur√°cia exata
        exact_matches = (valid_predictions['G√™nero_Real'] == valid_predictions['G√™nero_Predito']).sum()
        accuracy = exact_matches / len(valid_predictions)
        
        # Estat√≠sticas
        col1, col2, col3 = st.columns(3)
        
        with col1:
            st.metric(
                "Predi√ß√µes realizadas",
                f"{len(valid_predictions):,}"
            )
        
        with col2:
            st.metric(
                "Acur√°cia exata",
                f"{accuracy:.2%}"
            )
        
        with col3:
            st.metric(
                "Confian√ßa m√©dia",
                f"{valid_predictions['Confian√ßa'].mean():.2f}"
            )
        
        # Matriz de confus√£o simplificada (top g√™neros)
        st.subheader("üìä Matriz de Confus√£o (Top G√™neros)")
        
        confusion_data = []
        top_real_genres = valid_predictions['G√™nero_Real'].value_counts().head(5).index
        
        for real_genre in top_real_genres:
            real_subset = valid_predictions[valid_predictions['G√™nero_Real'] == real_genre]
            predicted_counts = real_subset['G√™nero_Predito'].value_counts()
            
            for pred_genre, count in predicted_counts.items():
                confusion_data.append({
                    'Real': real_genre,
                    'Predito': pred_genre,
                    'Quantidade': count
                })
        
        if confusion_data:
            confusion_df = pd.DataFrame(confusion_data)
            
            # Pivot para matriz
            confusion_matrix = confusion_df.pivot(index='Real', columns='Predito', values='Quantidade').fillna(0)
            
            fig_confusion = px.imshow(
                confusion_matrix,
                text_auto=True,
                title='Matriz de Confus√£o - G√™nero Real vs Predito',
                labels={'x': 'G√™nero Predito', 'y': 'G√™nero Real', 'color': 'Quantidade'},
                color_continuous_scale='Blues'
            )
            st.plotly_chart(fig_confusion, use_container_width=True)
        
        # Mostrar exemplos de predi√ß√µes
        st.subheader("üéØ Exemplos de Predi√ß√µes")
        
        # Exemplos corretos
        correct_predictions = valid_predictions[valid_predictions['G√™nero_Real'] == valid_predictions['G√™nero_Predito']].head(3)
        if len(correct_predictions) > 0:
            st.write("**‚úÖ Predi√ß√µes Corretas:**")
            for _, row in correct_predictions.iterrows():
                st.write(f"**{row['T√≠tulo']}** - Real: {row['G√™nero_Real']} | Predito: {row['G√™nero_Predito']} (Conf: {row['Confian√ßa']:.2f})")
                st.write(f"*{row['Overview']}*")
                st.write("---")
        
        # Exemplos incorretos
        incorrect_predictions = valid_predictions[valid_predictions['G√™nero_Real'] != valid_predictions['G√™nero_Predito']].head(3)
        if len(incorrect_predictions) > 0:
            st.write("**‚ùå Predi√ß√µes Incorretas:**")
            for _, row in incorrect_predictions.iterrows():
                st.write(f"**{row['T√≠tulo']}** - Real: {row['G√™nero_Real']} | Predito: {row['G√™nero_Predito']} (Conf: {row['Confian√ßa']:.2f})")
                st.write(f"*{row['Overview']}*")
                st.write("---")
    
    # ========== INSIGHTS FINAIS ==========
    st.subheader("üí° Principais Insights")
    
    insights = [
        f"üìè **Descri√ß√µes variam muito em tamanho:** de {df_overview['overview_length'].min()} a {df_overview['overview_length'].max()} caracteres",
        f"üìù **M√©dia de {df_overview['overview_words'].mean():.0f} palavras** por descri√ß√£o",
        f"üéØ **Modelo simples consegue {accuracy:.1%} de acur√°cia** na infer√™ncia de g√™neros",
        f"üîç **Palavras-chave mais comuns** revelam temas dominantes no cinema"
    ]
    
    if top_keywords:
        most_common_word = top_keywords[0][0]
        insights.append(f"üìä **Palavra mais comum:** '{most_common_word}' ({top_keywords[0][1]} ocorr√™ncias)")
    
    for insight in insights:
        st.markdown(insight)
    
    # Recomenda√ß√µes
    st.subheader("üéØ Recomenda√ß√µes para Melhoria")
    
    recommendations = [
        "**An√°lise de sentimento:** Implementar an√°lise de sentimento para entender o tom das descri√ß√µes",
        "**Modelo mais sofisticado:** Usar t√©cnicas de NLP avan√ßadas (TF-IDF, Word2Vec, BERT) para melhor infer√™ncia",
        "**An√°lise temporal:** Estudar como as descri√ß√µes evolu√≠ram ao longo das d√©cadas",
        "**Clustering:** Agrupar filmes por similaridade de descri√ß√£o para descobrir padr√µes ocultos",
        "**An√°lise de personagens:** Extrair informa√ß√µes sobre tipos de personagens mencionados"
    ]
    
    for rec in recommendations:
        st.markdown(f"‚Ä¢ {rec}")
    
    return pred_df

def page_analysis():
    st.title("An√°lise Explorat√≥ria de Dados (EDA)")
    
    db_path = "data/production.db"
    try:
        df = carregar_dados_db(db_path)
    except Exception as e:
        st.error(f"Erro ao carregar dados do banco: {e}")
        return

    tab1, tab2, tab3, tab4 = st.tabs(["üîó Correla√ß√µes Gerais", "üèÜ Recomenda√ß√µes", "üéØ An√°lise de Faturamento", "üìä An√°lise das Vis√µes Gerais dos Filmes"])

    with tab1:
        st.subheader("Matriz de Correla√ß√£o entre Vari√°veis Num√©ricas")
        st.markdown("Veja como as principais vari√°veis num√©ricas dos filmes se relacionam entre si. A matriz de correla√ß√£o abaixo destaca as rela√ß√µes mais fortes, tanto positivas quanto negativas, que podem influenciar o desempenho e a recep√ß√£o dos filmes.")
        plot_correlation_matrix(df)
    
    with tab2:
        st.subheader("Top 10 Filmes Recomendados (Alta Nota e Popularidade)")
        st.markdown("Confira os filmes mais recomendados, considerando tanto a avalia√ß√£o do p√∫blico quanto a popularidade. Os gr√°ficos a seguir mostram a distribui√ß√£o dos filmes populares e os g√™neros mais frequentes entre eles.")
        plot_top_recommendations(df)
    
    with tab3:
        st.subheader("An√°lise de Faturamento")
        st.markdown("Nesta se√ß√£o, vamos explorar os fatores que influenciam o faturamento dos filmes.")
        analise_fatores_faturamento(df)


    with tab4:
        st.subheader("An√°lise das Vis√µes Gerais dos Filmes")
        st.markdown("Nesta se√ß√£o, vamos explorar as vis√µes gerais dos filmes, incluindo aspectos como dire√ß√£o, elenco e produ√ß√£o.")
        analise_overview_insights(df)

if __name__ == "__main__":
    page_analysis()